# 堆排序
主要分为两点：
1. 堆的初始化
    > 遍历每个非叶子节点，进行一次局部的堆调整，可以让所有的最大值上浮，直至根节点 O(n)
2. 堆的调整
    > 1. 每次把最后的节点交换到根节点后，只需要进行局部调整即可;
    > 2. 每次局部调整是O(logn),相当于每一层调整一次
    > 3. 一共遍历了n次，所以是O(nlogn)
# 堆的上浮和下沉
堆插入即为上浮，把插入的元素放置到队尾，然后进行上浮调整
堆弹出即为下沉，把首位交换，新的队首进行下沉调整

# 代码说明
```c++
//1. 堆排序
//1.1 堆初始化，从第一个非叶子节点开始，向前进行堆调整
void heap_init(int* a, int root, int len);
//1.2 堆调整，对于每个root，判断其孩子是否有比它大的，如果有，与之交换，并对交换后的下沉的root继续调整
void heap_adjust_part(int* a,int root, int len);
//堆排序主体函数，
// a. 先初始化堆，令最大值上浮至队首，且队列满足大根堆需求
// b. 交换队首队尾，提取出第一个最大值放至队尾，且对剩余len-1部分进行调整
// c. 调整堆，每调整一次都可以获取剩余最大值，回到b.
// c. 调整次数达到len -1 即可退出
void heap_sort(int* a, int len);


//2. 堆结构的上浮和下沉(插入和弹出)
//2.1 堆插入->插入新元素至队尾->上浮：从最后一个非叶子节点开始往上调整
int heap_insert(int* a, int num, int len);
//2.2 堆弹出->交换队首队尾->下沉: 对新交换过来的队首，往下调整，等同于堆排序的堆调整
int heap_pop(int *a, int len);


//3. 堆类的封装
class Heap_BigTop;

```